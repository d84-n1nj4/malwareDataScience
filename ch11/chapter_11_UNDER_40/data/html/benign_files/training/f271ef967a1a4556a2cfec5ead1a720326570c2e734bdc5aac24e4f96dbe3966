<html><head></head><body><pre style="word-wrap: break-word; white-space: pre-wrap;">&lt;!--
function MM_reloadPage(init) {  //reloads the window if Nav4 resized
  if (init==true) with (navigator) {if ((appName=="Netscape")&amp;&amp;(parseInt(appVersion)==4)) {
    document.MM_pgW=innerWidth; document.MM_pgH=innerHeight; onresize=MM_reloadPage; }}
  else if (innerWidth!=document.MM_pgW || innerHeight!=document.MM_pgH) location.reload();
}
MM_reloadPage(true);


//Anti-spam email link - HTML "&lt;script language="JavaScript" type="text/javascript"&gt;email()&lt;/script&gt;"
function email() {
	user = "contact";
	site = "datacabs.com";
	document.write('&lt;a href=\"mailto:' + user + '@' + site + '?subject=website contact message\"&gt;');
	document.write(user + '@' + site + '&lt;/a&gt;');
	}
	
	function email_accounts() {
	user = "accounts";
	site = "datacabs.com";
	document.write('&lt;a href=\"mailto:' + user + '@' + site + '?subject=website contact message\"&gt;');
	document.write(user + '@' + site + '&lt;/a&gt;');
	}


	function email_enquires() {
	user = "enquires";
	site = "datacabs.com";
	document.write('&lt;a href=\"mailto:' + user + '@' + site + '?subject=website contact message\"&gt;');
	document.write(user + '@' + site + '&lt;/a&gt;');
	}

// Print Page - HTML &lt;a href="javascript:printPage()"&gt;Print this page&lt;/a&gt;
function printPage() {
  if (window.print)
    window.print()
  else
    alert("Sorry, your browser doesn't support this feature.");
}

// &lt;a href="#" onclick="return sure(this, 'log out ?')"&gt;
function user_message(thelink, id)
	{
	var is_confirmed = confirm('' + id + '');
		if (is_confirmed) {thelink.href;}
		return is_confirmed;
	}

// &lt;img name="pix" src="0.jpg"&gt;
// &lt;img src="file1_tmb.jpg" onclick="movepic('pix','file.jpg')"&gt;
function movepic(img_name,img_src) {
	document[img_name].src=img_src;
	}


function textCounter( field, countfield, maxlimit ) {
	  if ( field.value.length &gt; maxlimit )
	  {
		field.value = field.value.substring( 0, maxlimit );
		alert( 'Textarea is has limited in characters.' );
		return false;
	  }
	  else
	  {
		countfield.value = maxlimit - field.value.length;
	  }
	}


function SetAllCheckBoxes(FormName, FieldName, CheckValue)
	{
		if(!document.forms[FormName])
			return;
		var objCheckBoxes = document.forms[FormName].elements[FieldName];
		if(!objCheckBoxes)
			return;
		var countCheckBoxes = objCheckBoxes.length;
		if(!countCheckBoxes)
			objCheckBoxes.checked = CheckValue;
		else
			// set the check value for all check boxes
			for(var i = 0; i &lt; countCheckBoxes; i++)
				objCheckBoxes[i].checked = CheckValue;
	}


function opacityOn(elem){
	if(document.all){
	elem.filters.alpha.opacity = '100';
	}}

function opacityOff(elem){
	if(document.all){
	elem.filters.alpha.opacity = '50';
	}}


function toggleLayer(whichLayer)
{
if (document.getElementById)
{
// this is the way the standards work
var style2 = document.getElementById(whichLayer).style;
style2.display = style2.display? "":"block";
}
else if (document.all)
{
// this is the way old msie versions work
var style2 = document.all[whichLayer].style;
style2.display = style2.display? "":"block";
}
else if (document.layers)
{
// this is the way nn4 works
var style2 = document.layers[whichLayer].style;
style2.display = style2.display? "":"block";
}
}
/***********************************************************************
 * YAV - Yet Another Validator  v1.1.3                                 *
 * Copyright (C) 2005                                                  *
 * Author: Federico Crivellaro &lt;f.crivellaro@gmail.com&gt;                *
 * WWW: http://yav.sourceforge.net                                     *
 ***********************************************************************/
// CHANGE THESE VARIABLES FOR YOUR OWN SETUP

// if you want yav to highligh fields with errors
inputhighlight = true;
// classname you want for the error highlighting
inputclasserror = 'form_input_error';
// classname you want for your fields without highlighting
inputclassnormal = 'form_input_normal';
// classname you want for the inner html highlighting
innererror = 'form_inner_error';
// div name where errors will appear (or where jsVar variable is dinamically defined)
errorsdiv = 'form_errors';
// if you want yav to alert you for javascript errors (only for developers)
debugmode = false;
// if you want yav to trim the strings
trimenabled = true;

// change these to set your own decimal separator and your date format
DECIMAL_SEP ='.';
DATE_FORMAT = 'MM-dd-yyyy';

// change these strings for your own translation (do not change {n} values!)
HEADER_MSG = '';
FOOTER_MSG = '';
DEFAULT_MSG = 'The data is invalid.';
REQUIRED_MSG = 'Enter {1}.';
ALPHABETIC_MSG = '{1} is not valid. Characters allowed: A-Za-z';
ALPHANUMERIC_MSG = '{1} is not valid. Characters allowed: A-Za-z0-9';
ALNUMHYPHEN_MSG = '{1} is not valid. Characters allowed: A-Za-z0-9\-_';
ALNUMHYPHENAT_MSG = '{1} is not valid. Characters allowed: A-Za-z0-9\-_@';
ALPHASPACE_MSG = '{1} is not valid. Characters allowed: A-Za-z0-9\-_space';
MINLENGTH_MSG = '{1} must be at least {2} characters long.';
MAXLENGTH_MSG = '{1} must be no more than {2} characters long.';
NUMRANGE_MSG = '{1} must be a number in {2} range.';
DATE_MSG = '{1} is not a valid date, using the format ' + DATE_FORMAT + '.';
NUMERIC_MSG = '{1} must be a number.';
INTEGER_MSG = '{1} must be an integer';
DOUBLE_MSG = '{1} must be a decimal number.';
REGEXP_MSG = '{1} is not valid. Format allowed: {2}.';
EQUAL_MSG = '{1} must be equal to {2}.';
NOTEQUAL_MSG = '{1} must be not equal to {2}.';
DATE_LT_MSG = '{1} must be previous to {2}.';
DATE_LE_MSG = '{1} must be previous or equal to {2}.';
EMAIL_MSG = '{1} must be a valid e-mail.';
//------------------------------------------------------------ PUBLIC FUNCTIONS
var undef;

function performCheck(formName, strRules, alertType) {
    var rules = makeRules(strRules);
    this.f = document.forms[formName];
    if( !this.f ) {
        debug('DEBUG: could not find form object ' + formName);
        return null;
    }
    var errors = new Array();
    var ix = 0;
    if (rules.length) {
        for(var i=0; i&lt;rules.length; i++) {
            var aRule = rules[i];
            if (aRule!=null) {
                highlight(f.elements[aRule.el], inputclassnormal);
            }
        }
    } else {
        if (rules!=null) {
            highlight(f.elements[rules.el], inputclassnormal);
        }
    }
    if (rules.length) {
        for(var i=0; i&lt;rules.length; i++) {
            var aRule = rules[i];
            var anErr = null;
            if (aRule==null) {
                //do nothing
            } else if (aRule.ruleType=='pre-condition' || aRule.ruleType=='post-condition') {
                //do nothing
            } else if (aRule.ruleName=='implies') {
                pre  = aRule.el;
                post = aRule.comparisonValue;
                var oldClassName = f.elements[rules[pre].el].className;
                if ( checkRule(f, rules[pre])==null &amp;&amp; checkRule(f, rules[post])!=null ) {
                    anErr = aRule.alertMsg;
                } else if ( checkRule(f, rules[pre])!=null ) {
                    f.elements[rules[pre].el].className = oldClassName;
                }
            } else {
                anErr = checkRule(f, aRule);
            }
            if ( anErr!=null ) {
                errors[ix] = anErr;
                ix++;
            }
        }//for
    } else {
        var myRule = rules;
        err = checkRule(f, myRule);
        if ( err!=null ) {
            errors[0] = err;
        }
    }
    return displayAlert(errors, alertType);
}

function checkKeyPress(ev, obj, strRules) {
    var keyCode = null;
    if ( getBrowser()=='msie' ) {
        keyCode = window.event.keyCode;
    } else if ( getBrowser()=='netscape' || getBrowser()=='firefox' ) {
        keyCode = ev.which;
    }
    var rules = makeRules(strRules);
    var keyAllowed = true;
    if (rules.length) {
        for(var i=0; i&lt;rules.length; i++) {
            var aRule = rules[i];
            if (aRule.ruleName=='keypress' &amp;&amp; aRule.el==obj.name) {
                keyAllowed = isKeyAllowed(keyCode, aRule.comparisonValue);
                break;
            }
        }
    } else {
        var aRule = rules;
        if (aRule.ruleName=='keypress' &amp;&amp; aRule.el==obj.name) {
            keyAllowed = isKeyAllowed(keyCode, aRule.comparisonValue);
        }
    }
    if (!keyAllowed) {
        if ( getBrowser()=='msie' ) {
            window.event.keyCode=0;
        } else if ( getBrowser()=='netscape' || getBrowser()=='firefox' ) {
            ev.initKeyEvent('keypress', true, true, window, false, false, true, false, 0, 0x00, obj);
        }
    }
    return false;
}

//------------------------------------------------------------ PRIVATE FUNCTIONS

function displayAlert(messages, alertType) {
    var retval =null;
    if (alertType=='classic') {
        retval = displayClassic(messages);
    } else if (alertType=='innerHtml') {
        retval = displayInnerHtml(messages);
    }else if (alertType=='jsVar') {
        retval = displayJsVar(messages);
    } else {
        debug('DEBUG: alert type ' + alertType + ' not supported');
    }
    return retval;
}

function displayClassic(messages) {
    var str = '';
    if ( messages!=null &amp;&amp; messages.length&gt;0 ) {
    	if (strTrim(HEADER_MSG).length &gt; 0) {
            str += HEADER_MSG + '\n\n';
        }
        for (var i=0; i&lt;messages.length; i++) {
            str += ' ' + messages[i] + '\n';
        }
    	if (strTrim(FOOTER_MSG).length &gt; 0) {
            str += '\n' + FOOTER_MSG;
        }
        alert(str);
        return false;
    } else {
    	return true;
    }
}

function displayInnerHtml(messages) {
    if ( messages!=null &amp;&amp; messages.length&gt;0 ) {
        var str = '';
    	if (strTrim(HEADER_MSG).length &gt; 0) {
            str += HEADER_MSG;
        }
        str += '&lt;ul&gt;';
        for (var i=0; i&lt;messages.length; i++) {
            str += '&lt;li&gt;'+messages[i]+'&lt;/li&gt;';
        }
        str += '&lt;/ul&gt;';
    	if (strTrim(FOOTER_MSG).length &gt; 0) {
            str += FOOTER_MSG;
        }
        document.getElementById(errorsdiv).innerHTML = str;
        document.getElementById(errorsdiv).className = innererror;
        document.getElementById(errorsdiv).style.display = 'block';
        return false;
    } else {
        document.getElementById(errorsdiv).innerHTML = '';
        document.getElementById(errorsdiv).className = '';
        document.getElementById(errorsdiv).style.display = 'none';
        return true;
    }
}

function displayJsVar(messages) {
    document.getElementById(errorsdiv).className = '';
    document.getElementById(errorsdiv).style.display = 'none';
    if ( messages!=null &amp;&amp; messages.length&gt;0 ) {
        var str = '';
        str += '&lt;script&gt;var jsErrors;&lt;/script&gt;';
        document.getElementById(errorsdiv).innerHTML = str;
        jsErrors = messages;
        return false;
    } else {
        document.getElementById(errorsdiv).innerHTML = '&lt;script&gt;var jsErrors;&lt;/script&gt;';
        return true;
    }
}

function rule(el, ruleName, comparisonValue, alertMsg, ruleType) {
    if ( !checkArguments(arguments) ) {
        return false;
    }
    tmp = el.split(':');
    nameDisplayed = '';
    if (tmp.length == 2) {
        nameDisplayed = tmp[1];
        el = tmp[0];
    }
    this.el = el;
    this.nameDisplayed = nameDisplayed;
    this.ruleName = ruleName;
    this.comparisonValue = comparisonValue;
    this.ruleType = ruleType;
    if (alertMsg==undef || alertMsg==null) {
        this.alertMsg = getDefaultMessage(el, nameDisplayed, ruleName, comparisonValue);
    } else {
        this.alertMsg = alertMsg;
    }
}

function checkRule(f, myRule) {
    retVal = null;
    if (myRule != null) {
        if (myRule.ruleName=='custom') {
            var customFunction = ' retVal = ' + myRule.el;
            eval(customFunction);
        } else {
            el = f.elements[myRule.el];
            if (el == null) {
                debug('DEBUG: could not find element ' + myRule.el);
                return null;
            }
            var err = null;
            if(el.type) {
                if(el.type=='hidden'||el.type=='text'||el.type=='password'||el.type=='textarea') {
                    err = checkText(el, myRule);
                } else if(el.type=='checkbox') {
                    err = checkCheckbox(el, myRule);
                } else if(el.type=='select-one') {
                    err = checkSelOne(el, myRule);
                } else if(el.type=='select-multiple') {
                    err = checkSelMul(el, myRule);
                } else if(el.type=='radio') {
                    err = checkRadio(el, myRule);
                } else {
                    debug('DEBUG: type '+ el.type +' not supported');
                }
            } else {
                err = checkRadio(el, myRule);
            }
            retVal = err;
        }
    }
    return retVal;
}

function checkArguments(args) {
    if (args.length &lt; 4) {
        debug('DEBUG: rule requires four arguments at least');
        return false;
    } else if (args[0]==null || args[1]==null) {
        debug('DEBUG: el and ruleName are required');
        return false;
    }
    return true;
}

function checkRadio(el, myRule) {
    var err = null;
    if (myRule.ruleName=='required') {
        var radios = el;
	    var found=false;
	    if (isNaN(radios.length) &amp;&amp; radios.checked) {
	    	found=true;
	    } else {
		    for(var j=0; j &lt; radios.length; j++) {
		        if(radios[j].checked) {
		            found=true;
		            break;
		        }
		    }
		}
        if( !found ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='equal') {
        var radios = el;
	    var found=false;
	    if (isNaN(radios.length) &amp;&amp; radios.checked) {
	    	if (radios.value==myRule.comparisonValue) {
	    	    found=true;
	    	}
	    } else {
		    for(var j=0; j &lt; radios.length; j++) {
		        if(radios[j].checked) {
        	    	if (radios[j].value==myRule.comparisonValue) {
        	    	    found=true;
                        break;
        	    	}
		        }
		    }
		}
        if( !found ) {
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='notequal') {
        var radios = el;
	    var found=false;
	    if (isNaN(radios.length) &amp;&amp; radios.checked) {
	    	if (radios.value!=myRule.comparisonValue) {
	    	    found=true;
	    	}
	    } else {
		    for(var j=0; j &lt; radios.length; j++) {
		        if(radios[j].checked) {
        	    	if (radios[j].value!=myRule.comparisonValue) {
        	    	    found=true;
                        break;
        	    	}
		        }
		    }
		}
        if( !found ) {
            err = myRule.alertMsg;
        }
    } else {
        debug('DEBUG: rule ' + myRule.ruleName + ' not supported for radio');
    }
    return err;
}

function checkText(el, myRule) {
    err = null;
    if (trimenabled) {
    	el.value = strTrim(el.value);
    }
    if (myRule.ruleName=='required') {
        if ( el.value==null || el.value=='' ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='equal') {
        err = checkEqual(el, myRule);
    } else if (myRule.ruleName=='notequal') {
        err = checkNotEqual(el, myRule);
    } else if (myRule.ruleName=='numeric') {
        reg = new RegExp("^[0-9]*$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='alphabetic') {
        reg = new RegExp("^[A-Za-z]*$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='alphanumeric') {
        reg = new RegExp("^[A-Za-z0-9]*$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='alnumhyphen') {
        reg = new RegExp("^[A-Za-z0-9\-_]*$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='alnumhyphenat') {
        reg = new RegExp("^[A-Za-z0-9\-_@]*$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='alphaspace') {
        reg = new RegExp("^[A-Za-z0-9\-_ \n\r\t]*$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='email') {
        reg = new RegExp("^(([0-9a-zA-Z]+[-._+&amp;])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}){0,1}$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
	} else if (myRule.ruleName=='url') {
        reg = new RegExp("^(((ht|f)tp(s?))\:\/\/)?(www.|[a-zA-Z].)[a-zA-Z0-9\-\.]+\.(com|edu|gov|mil|net|org|biz|info|name|museum|us|ca|uk)(\:[0-9]+)*(/($|[a-zA-Z0-9\.\,\;\?\'\\\+&amp;%\$#\=~_\-]+))*$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='maxlength') {
        if ( isNaN(myRule.comparisonValue) ) {
            debug('DEBUG: comparisonValue for rule ' + myRule.ruleName + ' not a number');
        }else if ( el.value.length &gt; myRule.comparisonValue ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='minlength') {
        if ( isNaN(myRule.comparisonValue) ) {
            debug('DEBUG: comparisonValue for rule ' + myRule.ruleName + ' not a number');
        } else if ( el.value.length &lt; myRule.comparisonValue ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='numrange') {
        reg = new RegExp("^[0-9]*$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        } else {
            regRange = new RegExp("^[0-9]+-[0-9]+$");
            if ( !regRange.test(myRule.comparisonValue) ) {
                debug('DEBUG: comparisonValue for rule ' + myRule.ruleName + ' not in format number1-number2');
            } else {
                rangeVal = myRule.comparisonValue.split('-');
                if (eval(el.value)&lt;eval(rangeVal[0]) || eval(el.value)&gt;eval(rangeVal[1])) {
                    highlight(el, inputclasserror);
                    err = myRule.alertMsg;
                }
            }
        }
    } else if (myRule.ruleName=='regexp') {
        reg = new RegExp(myRule.comparisonValue);
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            err = myRule.alertMsg;
        }
    } else if (myRule.ruleName=='integer') {
        err = checkInteger(el, myRule);
    } else if (myRule.ruleName=='double') {
        err = checkDouble(el, myRule);
    } else if (myRule.ruleName=='date') {
        err = checkDate(el, myRule);
    } else if (myRule.ruleName=='date_lt') {
        err = checkDateLessThan(el, myRule, false);
    } else if (myRule.ruleName=='date_le') {
        err = checkDateLessThan(el, myRule, true);
    } else if (myRule.ruleName=='keypress') {
        // do nothing
    } else {
        debug('DEBUG: rule ' + myRule.ruleName + ' not supported for ' + el.type);
    }
    return err;
}

function checkInteger(el, myRule) {
    reg = new RegExp("^[-+]{0,1}[0-9]*$");
    if ( !reg.test(el.value) ) {
        highlight(el, inputclasserror);
        return myRule.alertMsg;
    }
}

function checkDouble(el, myRule) {
    var sep = DECIMAL_SEP;
    reg = new RegExp("^[-+]{0,1}[0-9]*[" + sep + "]{0,1}[0-9]*$");
    if ( !reg.test(el.value) ) {
        highlight(el, inputclasserror);
        return myRule.alertMsg;
    }
}

function checkDate(el, myRule) {
    error = null;
    if (el.value!='') {
        var dateFormat = DATE_FORMAT;
        ddReg = new RegExp("dd");
        MMReg = new RegExp("MM");
        yyyyReg = new RegExp("yyyy");
        if ( !ddReg.test(dateFormat) || !MMReg.test(dateFormat) || !yyyyReg.test(dateFormat)  ) {
            debug('DEBUG: locale format ' + dateFormat + ' not supported');
        } else {
            ddStart = dateFormat.indexOf('dd');
            MMStart = dateFormat.indexOf('MM');
            yyyyStart = dateFormat.indexOf('yyyy');
        }
        strReg = dateFormat.replace('dd','[0-9]{2}').replace('MM','[0-9]{2}').replace('yyyy','[0-9]{4}');
        reg = new RegExp("^" + strReg + "$");
        if ( !reg.test(el.value) ) {
            highlight(el, inputclasserror);
            error = myRule.alertMsg;
        } else {
            dd   = el.value.substring(ddStart, ddStart+2);
            MM   = el.value.substring(MMStart, MMStart+2);
            yyyy = el.value.substring(yyyyStart, yyyyStart+4);
            if ( !checkddMMyyyy(dd, MM, yyyy) ) {
                highlight(el, inputclasserror);
                error = myRule.alertMsg;
            }
        }
    }
    return error;
}

function checkDateLessThan(el, myRule, isEqualAllowed) {
    error = null;
    var isDate = checkDate(el, myRule)==null ? true : false;
    if ( isDate &amp;&amp; el.value!='' ) {
        var dateFormat = DATE_FORMAT;
        ddStart = dateFormat.indexOf('dd');
        MMStart = dateFormat.indexOf('MM');
        yyyyStart = dateFormat.indexOf('yyyy');
        dd   = el.value.substring(ddStart, ddStart+2);
        MM   = el.value.substring(MMStart, MMStart+2);
        yyyy = el.value.substring(yyyyStart, yyyyStart+4);
        myDate = "" + yyyy + MM + dd;
        strReg = dateFormat.replace('dd','[0-9]{2}').replace('MM','[0-9]{2}').replace('yyyy','[0-9]{4}');
        reg = new RegExp("^" + strReg + "$");
        var isMeta = myRule.comparisonValue.indexOf('$')==0 
            ? true
            : false;
        var comparisonDate = '';
        if (isMeta) {
            toSplit = myRule.comparisonValue.substr(1);
            tmp = toSplit.split(':');
            if (tmp.length == 2) {
                comparisonDate = this.f.elements[tmp[0]].value;
            } else {
                comparisonDate = this.f.elements[myRule.comparisonValue.substr(1)].value;
            }
        } else {
            comparisonDate = myRule.comparisonValue;
        }
        if ( !reg.test(comparisonDate) ) {
            highlight(el, inputclasserror);
            error = myRule.alertMsg;
        } else {
            cdd   = comparisonDate.substring(ddStart, ddStart+2);
            cMM   = comparisonDate.substring(MMStart, MMStart+2);
            cyyyy = comparisonDate.substring(yyyyStart, yyyyStart+4);
            cDate = "" + cyyyy + cMM + cdd;
            if (isEqualAllowed) {
                if ( !checkddMMyyyy(cdd, cMM, cyyyy) || myDate&gt;cDate ) {
                    highlight(el, inputclasserror);
                    error = myRule.alertMsg;
                }
            } else {
                if ( !checkddMMyyyy(cdd, cMM, cyyyy) || myDate&gt;=cDate ) {
                    highlight(el, inputclasserror);
                    error = myRule.alertMsg;
                }
            }
        }
    } else {
        if ( el.value!='' ) {
            highlight(el, inputclasserror);
            error = myRule.alertMsg;
        }
    }
    return error;
}

function checkEqual(el, myRule) {
    error = null;
    var isMeta = myRule.comparisonValue.indexOf('$')==0 
        ? true
        : false;
    var comparisonVal = '';
    if (isMeta) {
        toSplit = myRule.comparisonValue.substr(1);
        tmp = toSplit.split(':');
        if (tmp.length == 2) {
            comparisonVal = this.f.elements[tmp[0]].value;
        } else {
            comparisonVal = this.f.elements[myRule.comparisonValue.substr(1)].value;
        }
    } else {
        comparisonVal = myRule.comparisonValue;
    }
    if ( el.value!=comparisonVal ) {
        highlight(el, inputclasserror);
        error = myRule.alertMsg;
    }
    return error;
}

function checkNotEqual(el, myRule) {
    error = null;
    var isMeta = myRule.comparisonValue.indexOf('$')==0 
        ? true
        : false;
    var comparisonVal = '';
    if (isMeta) {
        toSplit = myRule.comparisonValue.substr(1);
        tmp = toSplit.split(':');
        if (tmp.length == 2) {
            comparisonVal = this.f.elements[tmp[0]].value;
        } else {
            comparisonVal = this.f.elements[myRule.comparisonValue.substr(1)].value;
        }
    } else {
        comparisonVal = myRule.comparisonValue;
    }
    if ( el.value==comparisonVal ) {
        highlight(el, inputclasserror);
        error = myRule.alertMsg;
    }
    return error;
}

function checkddMMyyyy(dd, MM, yyyy) {
    retVal = true;
    if (    (dd &gt; 31) || (MM &gt; 12) ||
            (dd==31 &amp;&amp; (MM==2 || MM==4 || MM==6 || MM==9 || MM==11) ) ||
            (dd &gt;29 &amp;&amp; MM==2) ||
            (dd==29 &amp;&amp; (MM==2) &amp;&amp; ((yyyy%4 &gt; 0) || (yyyy%4==0 &amp;&amp; yyyy%100==0 &amp;&amp; yyyy%400&gt;0 )) )) {
       retVal = false;
    }
    return retVal;
}

function checkCheckbox(el, myRule) {
    if (myRule.ruleName=='required') {
        if ( !el.checked ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else if (myRule.ruleName=='equal') {
        if ( !el.checked || el.value!=myRule.comparisonValue ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else if (myRule.ruleName=='notequal') {
        if ( !el.checked || el.value==myRule.comparisonValue ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else {
        debug('DEBUG: rule ' + myRule.ruleName + ' not supported for ' + el.type);
    }
}

function checkSelOne(el, myRule) {
    if (myRule.ruleName=='required') {
        var found = false;
        var inx = el.selectedIndex;
        if(inx&gt;=0 &amp;&amp; el.options[inx].value) {
            found = true;
        }
        if ( !found ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else if (myRule.ruleName=='equal') {
        var found = false;
        var inx = el.selectedIndex;
        if(inx&gt;=0 &amp;&amp; el.options[inx].value==myRule.comparisonValue) {
            found = true;
        }
        if ( !found ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else if (myRule.ruleName=='notequal') {
        var found = false;
        var inx = el.selectedIndex;
        if(inx&gt;=0 &amp;&amp; el.options[inx].value!=myRule.comparisonValue) {
            found = true;
        }
        if ( !found ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else {
        debug('DEBUG: rule ' + myRule.ruleName + ' not supported for ' + el.type);
    }
}

function checkSelMul(el, myRule) {
    if (myRule.ruleName=='required') {
        var found = false;
        opts = el.options;
        for(var i=0; i&lt;opts.length; i++) {
            if(opts[i].selected &amp;&amp; opts[i].value) {
                found = true;
                break;
            }
        }
        if ( !found ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else if (myRule.ruleName=='equal') {
        var found = false;
        opts = el.options;
        for(var i=0; i&lt;opts.length; i++) {
            if(opts[i].selected &amp;&amp; opts[i].value==myRule.comparisonValue) {
                found = true;
                break;
            }
        }
        if ( !found ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else if (myRule.ruleName=='notequal') {
        var found = false;
        opts = el.options;
        for(var i=0; i&lt;opts.length; i++) {
            if(opts[i].selected &amp;&amp; opts[i].value!=myRule.comparisonValue) {
                found = true;
                break;
            }
        }
        if ( !found ) {
            highlight(el, inputclasserror);
            return myRule.alertMsg;
        }
    } else {
        debug('DEBUG: rule ' + myRule.ruleName + ' not supported for ' + el.type);
    }
}

function debug(msg) {
    if (debugmode) {
        alert(msg);
    }
}

function strTrim(str) {
    return str.replace(/^\s+/,'').replace(/\s+$/,'');
}

function makeRules(strRules) {
    var rules=new Array();
    if (strRules.length) {
        for(var i=0; i&lt;strRules.length; i++) {
            rules[i] = splitRule(strRules[i]);
        }
    } else {
        rules[0] = splitRule(strRules);
    }
    return rules;
}

function splitRule(strRule) {
    var retval = null;
    if (strRule!=undef) {
        params = strRule.split('|');
        switch (params.length) {
            case 2:
                retval = new rule(params[0], params[1], null, null, null);
                break;
            case 3:
                if (threeParamRule(params[1])) {
                    retval = new rule(params[0], params[1], params[2], null, null);
                } else if (params[2]=='pre-condition' || params[2]=='post-condition') {
                    retval = new rule(params[0], params[1], null, 'foo', params[2]);
                } else {
                    retval = new rule(params[0], params[1], null, params[2], null);
                }
                break;
            case 4:
                if (threeParamRule(params[1]) &amp;&amp; (params[3]=='pre-condition' || params[3]=='post-condition')) {
                    retval = new rule(params[0], params[1], params[2], 'foo', params[3]);
                } else {
                    retval = new rule(params[0], params[1], params[2], params[3], null);
                }
                break;
            default:
                debug('DEBUG: wrong definition of rule');
        }
    }
    return retval;
}

function threeParamRule(ruleName) {
    return (ruleName=='equal' || ruleName=='notequal' || ruleName=='minlength' || ruleName=='maxlength' || ruleName=='date_lt' || ruleName=='date_le' || ruleName=='implies' || ruleName=='regexp' || ruleName=='numrange' || ruleName=='keypress')
        ? true
        : false;
}

function highlight(el, clazz) {
    if (el!=undef &amp;&amp; inputhighlight) {
        el.className = clazz;
    }
}

function getDefaultMessage(el, nameDisplayed, ruleName, comparisonValue) {
    if (nameDisplayed.length == 0) {
        nameDisplayed = el;
    }
    var msg = DEFAULT_MSG;
    if (ruleName=='required') {
        msg = REQUIRED_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='minlength') {
        msg = MINLENGTH_MSG.replace('{1}', nameDisplayed).replace('{2}', comparisonValue);
    } else if (ruleName=='maxlength') {
        msg = MAXLENGTH_MSG.replace('{1}', nameDisplayed).replace('{2}', comparisonValue);
    } else if (ruleName=='numrange') {
        msg = NUMRANGE_MSG.replace('{1}', nameDisplayed).replace('{2}', comparisonValue);
    } else if (ruleName=='date') {
        msg = DATE_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='numeric') {
        msg = NUMERIC_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='integer') {
        msg = INTEGER_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='double') {
        msg = DOUBLE_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='equal') {
        msg = EQUAL_MSG.replace('{1}', nameDisplayed).replace('{2}', getComparisonDisplayed(comparisonValue));
    } else if (ruleName=='notequal') {
        msg = NOTEQUAL_MSG.replace('{1}', nameDisplayed).replace('{2}', getComparisonDisplayed(comparisonValue));
    } else if (ruleName=='alphabetic') {
        msg = ALPHABETIC_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='alphanumeric') {
        msg = ALPHANUMERIC_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='alnumhyphen') {
        msg = ALNUMHYPHEN_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='alnumhyphenat') {
        msg = ALNUMHYPHENAT_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='alphaspace') {
        msg = ALPHASPACE_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='email') {
        msg = EMAIL_MSG.replace('{1}', nameDisplayed);
    } else if (ruleName=='regexp') {
        msg = REGEXP_MSG.replace('{1}', nameDisplayed).replace('{2}', comparisonValue);
    } else if (ruleName=='date_lt') {
        msg = DATE_LT_MSG.replace('{1}', nameDisplayed).replace('{2}', getComparisonDisplayed(comparisonValue));
    } else if (ruleName=='date_le') {
        msg = DATE_LE_MSG.replace('{1}', nameDisplayed).replace('{2}', getComparisonDisplayed(comparisonValue));
    }
    return msg;
}

function getComparisonDisplayed(comparisonValue) {
    comparisonDisplayed = comparisonValue;
    if (comparisonValue.substring(0, 1)=='$') {
        comparisonValue = comparisonValue.substring(1, comparisonValue.length);
        tmp = comparisonValue.split(':');
        if (tmp.length == 2) {
            comparisonDisplayed = tmp[1];
        } else {
            comparisonDisplayed = comparisonValue;
        }
    }
    return comparisonDisplayed;
}

function getBrowser() {
    brs=navigator.userAgent.toLowerCase();
    var retval;
    if (brs.search(/msie\s(\d+(\.?\d)*)/)!=-1) {
        retval='msie';
    } else if (brs.search(/netscape[\/\s](\d+([\.-]\d)*)/)!=-1) {
        retval='netscape';
    } else if (brs.search(/firefox[\/\s](\d+([\.-]\d)*)/)!=-1) {
        retval='firefox';
    } else {
        retval='unknown';
    }
    return retval;
}

function isKeyAllowed(keyCode, charsAllowed) {
    retval = false;
    var aCharCode;
    if (keyCode==8) {
        retval = true;
    } else {
        for(var i=0; i&lt;charsAllowed.length; i++) {
            aCharCode = charsAllowed.charCodeAt(i);
            if (aCharCode==keyCode) {
                retval = true;
                break;
            }
        }
    }
    return retval;
}
//end
//--&gt;</pre></body></html>